<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何在CentOS7下安装redis]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%9C%A8CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85redis%2F</url>
    <content type="text"><![CDATA[本文主要介绍了如何在linux系统中如何安装redis。 前言请根据需要安装对应版本的redis，一般推荐安装最新版本的稳定版本。见官网：https://redis.io/ 最下面的Download it.Redis约定版本号第一个次版本号为偶数（如3.0、3.2等）表示稳定版，奇数(如3.1、3.5等)为非稳定版本。 注：文章中 $ 表示这一条linxu命令 下载安装包1$ wget http://download.redis.io/releases/redis-4.0.2.tar.gz 注：上面的地址使用4.0.2版本，其他的版本请对应地址下载。 压缩和安装1234$ tar xzf redis-4.0.11.tar.gz$ cd redis-4.0.11$ make$ mark install 安装完成后，可以/usr/local/bin目录下找到刚刚安装的redis执行文件，见下图： 启动和停止Redis在/usr/local/bin目录下，输入命令redis-server直接运行Redis，我们可以看到如下结果，表示Redis已经成功运行！我们可以看到，Redis默认运行在6379端口。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net Core身份认证框架IdentityServer4（8）使用asp.net core的identity]]></title>
    <url>%2F2018%2F09%2F14%2Fids4_8_%E4%BD%BF%E7%94%A8asp-net-core-identity%2F</url>
    <content type="text"><![CDATA[IdentityServer是为灵活性而设计的，其中一部分允许你为你的用户及其数据(包括密码)使用任何数据库。如果你正使用一个新的用户数据库开始，Asp.net Identity是一种选择。这个快速入门展示了如果使用Asp.net Identity和IdentityServer。 这个快速入门假设你已经通过了之前所有的快速入门示例。这个快速入门通过使用Visual Studio的Asp.net Identity模板创建一个新的项目来使用Asp.net Identity。这个新的项目将替换之前的IdentityServer项目。这个解决方案中其他的项目依然一样（例如客户端、api项目）。 Asp.net Identity新项目第一步是添加一个新的Asp.net Identity项目到你的解决方案中。 考虑到Asp.net Identity需要大量的代码，使用Visual Studio的模板是很有意义的。你可以完全删除旧的IdentityServer项目(假设你在其他的快速入门项目继续)，但是有几个项目您需要进行迁移(或者像前面的quickstart中描述的那样从头重写)。 开始，创建一个新的”Asp.net Web应用程序”项目。 选择“Web 应用程序(模型视图控制器)”选项，选择.net core的版本为ASP.NET Core 2.0。 然后点击“更改身份认证”按钮，选择“个人用户账号”(表示使用Asp.net Identity) 修改宿主(host)不要忘记修改宿主运行在5000端口(见之前章节)。这对于保证已经存在的客户端和API项目能够继续允许非常重要。 添加IdentityServer 包添加IdentityServer4.AspNetIdentityNuget包。它依赖于IdentityServer4包，因此IdentityServer4作为传递依赖会被自动添加。在程序包管理器控制台执行以下命令安装：1PM&gt; Install-Package IdentityServer4.AspNetIdentity 作用域和客户端配置尽管这是一个新的IdentityServer项目，我们仍然需要像之前的快速入门项目一样的作用域和客户端配置。将你之前的快速入门项目中使用的配置类(Config.cs)拷贝到新的项目中。 在配置中，为MVC客户端禁用consent这个更改是必须的。我们还没有从先前的IdentityServer项目复制consent代码。现在，对MVC客户端进行一次修改，并设置RequireConsent=false。1234567891011121314var client = new Client&#123; ClientId = "mvc", ClientName = "MVC Client", RequireConsent=false, //使用Hybrid flow认证 AllowedGrantTypes = GrantTypes.HybridAndClientCredentials, //客户端密钥 ClientSecrets = &#123; new Secret("secret".Sha256()) &#125;, 以上配置仅贴出部分代码 配置IdentityServer与之前一样，IdentityServer需要在Startup.cs文件中的ConfigureServices和Configure配置。 ConfigureServices下面展示的代码包括了为Asp.net Identity生成的模板代码，同时也有IdentityServer(在最后)需要的代码。在之前的快速入门中，AddTestUsers扩展方法被用来注册用户。但是在这个解决方案中，我们通过替换为AddAspNetIdentity扩展方法，使用ASP.NET Identity用户来替代。AddAspNetIdentity扩展方法需要一个通用参数，这个参数既是你的Asp.net Identity用户类型（与来自模板的AddIdentity方法一样）12345678910111213141516171819202122public void ConfigureServices(IServiceCollection services)&#123; services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt; options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection"))); services.AddDefaultIdentity&lt;IdentityUser&gt;() .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;() .AddDefaultTokenProviders(); services.AddTransient&lt;IEmailSender, EmailSender&gt;(); services.AddMvc(); services.AddIdentityServer() .AddDeveloperSigningCredential() .AddInMemoryPersistedGrants() .AddInMemoryApiResources(Config.GetApiResources()) .AddInMemoryClients(Config.GetClients()) .AddTestUsers(Config.GetUsers()) .AddInMemoryIdentityResources(Config.GetIdentityResources()) .AddAspNetIdentity&lt;IdentityUser&gt;();&#125; 注意当使用Asp.net Identity时，IdentityServer在Asp.net Identity之后注册到依赖注入系统(DI System)是非常重要的。因为IdentityServer会重写Asp.net Identity的一些配置。 Configure下面展示的代码包括了为Asp.net Identity生成的模板代码，同时调用UseIdentityServer替换原先的UseAuthentication。 1234567891011121314151617181920212223242526public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); app.UseDatabaseErrorPage(); &#125; else &#123; app.UseExceptionHandler("/Home/Error"); app.UseHsts(); &#125; app.UseStaticFiles(); //app.UseAuthentication(); //使用UseIdentityServer替换默认的UseAuthentication app.UseIdentityServer(); app.UseMvc(routes =&gt; &#123; routes.MapRoute( name: "default", template: "&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;"); &#125;);&#125; 创建用户数据库假设这是一个新的Asp.net Identity项目，你需要创建数据库。打开程序包管理控制台，默认项目选择为IdentityServerWithAspNetIdentity(根据实际创建的名称选择)，然后输入命令：1PM&gt; Update-database 创建用户此时，你可以运行项目然后创建/注册一个用户到数据库。启动应用程序，然后在首页点击”Register”按钮，完成用户注册。现在，你拥有一个用户账号，你可以登录，使用客户端以及调用APIs。 登录MVC客户端启动MVC客户端应用程序，点击需要认证的页面，系统会自动重定向到Asp.net Identity的登录页。]]></content>
      <categories>
        <category>Identity Server 4</category>
      </categories>
      <tags>
        <tag>Identity Server 4</tag>
        <tag>Asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net Core身份认证框架IdentityServer4（7）切换到混合流并添加API访问]]></title>
    <url>%2F2018%2F09%2F08%2Fids4_7_%E5%88%87%E6%8D%A2%E5%88%B0%E6%B7%B7%E5%90%88%E6%B5%81%E5%B9%B6%E6%B7%BB%E5%8A%A0API%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[在之前的快速入门示例中，我们探索了API访问和用户身份认证。现在我们要把这两部分结合起来。 OpenID Connect 和 OAuth 2.0 结合的美妙之处在于，你可以使用单个协议和使用令牌服务单次交换来实现两者。 上一个例子中，我们使用了OpenID Connect显示流(implicit flow)。在显示流中所有的令牌都是通过浏览器传输的，这对于身份令牌（identity token）来说完全没有问题。现在我们也想请求一个访问令牌（access token）。 访问令牌比身份令牌更加敏感，若无必要，我们不希望把它们暴露给‘外部’的世界。OpenID Connect包含一个叫’Hybrid Flow’(混合流)的流程，为我们提供了两全齐美的优势。身份令牌通过浏览器通道传输，因此客户端可以在进行其他任何更多工作前验证它。假如验证成功，客户端会打开一个令牌服务的反响通道取回访问令牌。 修改客户端配置没有太多必要的修改。首先，我们希望允许客户端使用混合流(hybrid flow)。同时，我们还希望允许客户端执行不在用户上下文(context)中的服务端到服务端API的调用(这与我们之前的客户端凭据快速开始项目非常相似)。这里使用AllowedGrantTypes属性表示。 下一步，我们需要添加一个客户端密钥。它将用于取回反向通道上的访问令牌。 最后，我们还让客户端访问offline_acess作用域-这允许为长连接的API访问请求刷新令牌：12345678910111213141516171819202122232425262728293031323334353637383940/// &lt;summary&gt;/// 添加Hybrid flow客户端/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IEnumerable&lt;Client&gt; GetClients()&#123; var list = new List&lt;Client&gt;(); //使用用户凭据认证 var client = new Client &#123; ClientId = "mvc", ClientName = "MVC Client", //使用Hybrid flow认证 AllowedGrantTypes = GrantTypes.HybridAndClientCredentials, //客户端密钥 ClientSecrets = &#123; new Secret("secret".Sha256()) &#125;, //登录后重定向地址 RedirectUris = &#123; "http://localhost:5002/signin-oidc" &#125;, //注销后重定向地址 PostLogoutRedirectUris = &#123; "http://localhost:5002/signout-callback-oidc" &#125;, //客户端要访问的作用域(Identity) AllowedScopes = &#123; IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, "api1" //保护api &#125;, //允许刷新acess token AllowOfflineAccess=true &#125;; list.Add(client); return list;&#125; 修改MVC客户端在MVC客户端的修改同样很少-ASP.NET Core OpenID Connect处理程序内置了对hybrid flow的支持，因此我们仅仅需要该百年一些配置值就可以了。 我们配置ClientSecret匹配IdentityServer的secret。添加offline_access和api1作用域，并且设置ResponseType值为code id_token(基本上意思就是”使用hybrid flow”)123456789101112131415.AddOpenIdConnect("oidc", options =&gt; &#123; options.SignInScheme = "Cookies"; options.Authority = "http://localhost:5000"; options.RequireHttpsMetadata = false; options.ClientId = "mvc"; options.ClientSecret = "secret"; options.ResponseType = "code id_token"; options.SaveTokens = true; options.GetClaimsFromUserInfoEndpoint = true; options.Scope.Add("api1"); options.Scope.Add("offline_access");&#125;); 当你运行MVC客户端时，这没有太大的差异，此外consent屏幕现在会要求你提供额外的API和offline access 作用域。 使用访问令牌OpenID Connect中间件自动为你保存令牌(在我们示例中的identity、acess和refresh令牌)。这就是SaveTokens配置所做的。 从技术上讲，令牌存储在cookie的属性中。访问它们最简单的办法是使用来自Microsoft.AspNetCore.Authentication命名空间的扩展方法。 例如在你的claims视图中：12345&lt;dt&gt;access token&lt;/dt&gt;&lt;dd&gt;@await ViewContext.HttpContext.GetTokenAsync("access_token")&lt;/dd&gt;&lt;dt&gt;refresh token&lt;/dt&gt;&lt;dd&gt;@await ViewContext.HttpContext.GetTokenAsync("refresh_token")&lt;/dd&gt; 为使用access token访问API，你所需要做的就是取回令牌，然后再你的httpClient设置它：1234567891011public async Task&lt;IActionResult&gt; CallApiUsingUserAccessToken()&#123; var accessToken = await HttpContext.GetTokenAsync("access_token"); var client = new HttpClient(); client.SetBearerToken(accessToken); var content = await client.GetStringAsync("http://localhost:5001/identity"); ViewBag.Json = JArray.Parse(content).ToString(); return View("json");&#125; 注:SetBearerToken扩展方法在IdentityModel包中，需要添加包的引用：1$ install-package IdentityModel]]></content>
      <categories>
        <category>Identity Server 4</category>
      </categories>
      <tags>
        <tag>Identity Server 4</tag>
        <tag>Asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net Core访问远程文件夹]]></title>
    <url>%2F2018%2F09%2F05%2FAsp-net-Core%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[最近在使用asp.net core开发项目，系统应用部署在A服务器，上传文件放在一台远程共享文件服务器B中（\\10.1.0.10）。 参考以前asp.net的项目经验，可以在IIS中创建虚拟目录files(如果有权限控制，虚拟目录还需要添加权限账号)指向文件服务器B，然后使用以下代码获取物理路径：1var physicalPath=Server.MapPath("/files"); 但是，在.net core中，我们发现已经没有Server.MapPath()方法了。当我们需要获取物理路径时，通常是通过注入IHostingEnvironment，然后使用_hostEnvironment.WebRootPath来获取站点的默认文件根路径(wwwroot)。 那么，可以像asp.net一样，通过虚拟目录访问远程文件服务器文件么？ 答案是不能！我找到一篇资料：ASP.NET Core/IIS: serving content from a file share There are situations, when you want to serve static content with your application, that is not part of it, e.g. because it exists on a common file share. Website content, that is managed by a business division, could be such a use case. In ASP.NET before Core, this was no problem in IIS: just create a virtual directory within your IIS website and point it to the file share. Unfortunately, with ASP.NET Core, this approach isn’t working any longer. If you add a virtual directory to your ASP.NET Core application in IIS, it isn’t recognized and a 404 is returned. It’s because of DNX/Kestrel, which is running beneath IIS (using the HttpPlatformHandler module) and to which IIS only brokers the requests. Kestrel doesn’t know anything of virtual directories from IIS. And because ASP.NET Core applications are independent from IIS and could also be run without it (e.g. running Kestrel standalone), that should be considered as a good thing. .net core为了跨平台，可以寄宿在任何宿主中，IIS仅仅是作为反向代理来处理请求，所以Kestrel是不知道来自IIS虚拟目录的任何内容的。 既然使用虚拟目录的方式不行，那还有其他什么办法呢？ 通过搜索，我看到微软官方的一篇文章，介绍如何指定静态文件路径：Static files in ASP.NET Core，可简单在Startup.cs的Configure配置： 1234567891011public void Configure(IApplicationBuilder app)&#123; app.UseStaticFiles(); //添加远程文件目录的访问 app.UseStaticFiles(new StaticFileOptions() &#123; FileProvider = new PhysicalFileProvider(@"\\10.1.0.10\files"), RequestPath = "/files" &#125;);&#125; app.UseStaticFiles()可以使用多个，其中无参数的默认指向wwwroot文件夹。 运行程序，很不幸的是，系统直接抛出一个异常： System.ArgumentException:“The directory name \10.1.0.10\files\ is invalid.” 原因是文件夹有权限控制，无法直接访问。 继续查资料，在stackoverflow看到这么一条回复：ASP.NET Read Files from a Password Protected Network Share ，里面提到可以使用WNetAddConnection2建立远程文件目录映射。 这里我们可以看一下微软对WNetAddConnection2的描述： The WNetAddConnection2 function makes a connection to a network resource and can redirect a local device to the network resource. 意思是说，WNetAddConnection2方法可以建立网络资源链接，并且将一个本地驱动到重定向到网络资源。(简单来说就是可以映射网络驱动器) 修改Configure代码（此处仅给出Configure中部分代码，其他的注入按实际项目添加。）123456789101112131415161718public void Configure(IApplicationBuilder app)&#123; app.UseStaticFiles(); //添加网络隐射 var result = Drived.NetworkConnection.Connect("\\10.1.0.10\files", "P:", "userAccount", "password"); if (result != 0) throw new Exception($"远程文件目录映射失败！返回结果：&#123;result&#125;"); //添加远程文件目录的访问 app.UseStaticFiles(new StaticFileOptions() &#123; FileProvider = new PhysicalFileProvider(ReportSettings.RemoteFileMap), RequestPath = "/files" &#125;); Drived.NetworkConnection完整代码贴在最后 运行程序，很不幸抛出异常：‘远程文件目录映射失败！返回结果：1312’。我们来看看1312错误究竟是个什么鬼，参考微软官方文档的描述：System Error Codes 1312 (0x520) A specified logon session does not exist. It may already have been terminated. 登录会话不存在？因为我在本机开发环境运行，已经能够正常访问。猜测是程序发布到IIS后，IIS程序池无权限的问题。 设置IIS站点应用权限 IIS-&gt;应用程序池-&gt;当前站点的程序-&gt;高级设置 配置完成后，重启应用程序池。再次运行，访问http://localhost:62144/files/test.png，结果如下： 以下是Drived.NetworkConnection的完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public static class Drived&#123; public enum ERROR_ID &#123; ERROR_SUCCESS = 0, // Success ERROR_ACCESS_DENIED = 5, ERROR_NOT_ENOUGH_MEMORY = 8, ERROR_READ_FAULT = 30, Windows_cannot_find_the_network_path = 51, ERROR_BAD_NETPATH = 53, ERROR_NETWORK_BUSY = 54, ERROR_NETWORK_ACCESS_DENIED = 65, ERROR_BAD_DEV_TYPE = 66, ERROR_BAD_NET_NAME = 67, ERROR_REQ_NOT_ACCEP = 71, ERROR_ALREADY_ASSIGNED = 85, ERROR_INVALID_PASSWORD = 86, ERROR_INVALID_PARAMETER = 87, ERROR_OPEN_FAILED = 110, ERROR_INVALID_LEVEL = 124, ERROR_BUSY = 170, ERROR_MORE_DATA = 234, ERROR_NO_BROWSER_SERVERS_FOUND = 6118, ERROR_NO_NETWORK = 1222, ERROR_INVALID_HANDLE_STATE = 1609, ERROR_EXTENDED_ERROR = 1208, ERROR_DEVICE_ALREADY_REMEMBERED = 1202, ERROR_NO_NET_OR_BAD_PATH = 1203, the_user_has_not_been_granted_the_requested_logon_type_at_this_computer = 1385, unknown_user_name_or_bad_password = 1326, ERROR_ACCOUNT_RESTRICTION = 1327, ERROR_INVALID_WORKSTATION = 1329, logon_request_contained_an_invalid_logon_type_value = 1367, &#125; public enum RESOURCE_SCOPE &#123; RESOURCE_CONNECTED = 1, RESOURCE_GLOBALNET = 2, RESOURCE_REMEMBERED = 3, RESOURCE_RECENT = 4, RESOURCE_CONTEXT = 5 &#125; public enum RESOURCE_TYPE &#123; RESOURCETYPE_ANY = 0, RESOURCETYPE_DISK = 1, RESOURCETYPE_PRINT = 2, RESOURCETYPE_RESERVED = 8, &#125; public enum RESOURCE_USAGE &#123; RESOURCEUSAGE_CONNECTABLE = 1, RESOURCEUSAGE_CONTAINER = 2, RESOURCEUSAGE_NOLOCALDEVICE = 4, RESOURCEUSAGE_SIBLING = 8, RESOURCEUSAGE_ATTACHED = 16, RESOURCEUSAGE_ALL = (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER | RESOURCEUSAGE_ATTACHED), &#125; public enum RESOURCE_DISPLAYTYPE &#123; RESOURCEDISPLAYTYPE_GENERIC = 0, RESOURCEDISPLAYTYPE_DOMAIN = 1, RESOURCEDISPLAYTYPE_SERVER = 2, RESOURCEDISPLAYTYPE_SHARE = 3, RESOURCEDISPLAYTYPE_FILE = 4, RESOURCEDISPLAYTYPE_GROUP = 5, RESOURCEDISPLAYTYPE_NETWORK = 6, RESOURCEDISPLAYTYPE_ROOT = 7, RESOURCEDISPLAYTYPE_SHAREADMIN = 8, RESOURCEDISPLAYTYPE_DIRECTORY = 9, RESOURCEDISPLAYTYPE_TREE = 10, RESOURCEDISPLAYTYPE_NDSCONTAINER = 11 &#125; [StructLayout(LayoutKind.Sequential)] public struct NETRESOURCE &#123; public RESOURCE_SCOPE dwScope; public RESOURCE_TYPE dwType; public RESOURCE_DISPLAYTYPE dwDisplayType; public RESOURCE_USAGE dwUsage; [MarshalAs(UnmanagedType.LPStr)] public string lpLocalName; [MarshalAs(UnmanagedType.LPStr)] public string lpRemoteName; [MarshalAs(UnmanagedType.LPStr)] public string lpComment; [MarshalAs(UnmanagedType.LPStr)] public string lpProvider; &#125; public class NetworkConnection &#123; [DllImport("mpr.dll")] public static extern int WNetAddConnection2(NETRESOURCE[] lpNetResource, string lpPassword, string lpUserName, int dwFlags); [DllImport("mpr.dll")] public static extern int WNetCancelConnection2(string sharename, int dwFlags, int fForce); public static int Connect(string remotePath, string localPath, string username, string password) &#123; NETRESOURCE[] share_driver = new NETRESOURCE[1]; share_driver[0].dwScope = RESOURCE_SCOPE.RESOURCE_GLOBALNET; share_driver[0].dwType = RESOURCE_TYPE.RESOURCETYPE_DISK; share_driver[0].dwDisplayType = RESOURCE_DISPLAYTYPE.RESOURCEDISPLAYTYPE_SHARE; share_driver[0].dwUsage = RESOURCE_USAGE.RESOURCEUSAGE_CONNECTABLE; share_driver[0].lpLocalName = localPath; share_driver[0].lpRemoteName = remotePath; Disconnect(localPath); int ret = WNetAddConnection2(share_driver, password, username, 1); return ret; &#125; public static int Disconnect(string localpath) &#123; return WNetCancelConnection2(localpath, 1, 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Asp.net core</category>
      </categories>
      <tags>
        <tag>Asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net Core身份认证框架IdentityServer4（6）使用OpenID Connect添加用户认证]]></title>
    <url>%2F2018%2F09%2F02%2Fids4_6_%E4%BD%BF%E7%94%A8OpenID-Connect%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[在这个项目示例中，我们想通过OpenID Connect协议为IdentityServer添加交互用户认证的支持。 我们将创建一个使用IdentityServer认证的MVC应用程序。 添加UIOpenID Connect所需要的所有协议支持都已经内置到IdentityServer。你需要为登录、注销、同意协议、错误等页面提供必需的UI部分。 虽然在每个IdentityServer实现中，外观和确切的工作流可能总是不同的，我们提供一个基于MVC的示例UI，你可以作为开始使用。 你可以在Quickstart UI repo找到这个UI。你也可以克隆或下载这个项目，然后复制controllers, views, models和CSS到你的IdentityServer Web应用程序(先前创建的Identity Server应用程序)。 一旦你添加了MVC UI 资源，你同样需要添加MVC到依赖注入(DI)系统和管道中。使用AddMVC扩展方法添加MVC到ConfigureServices：1234567891011public void ConfigureServices(IServiceCollection services)&#123; services.AddMvc(); //IdentityServer配置in-memory存储,键(Keys),客户端和资源，测试用户 services.AddIdentityServer() .AddDeveloperSigningCredential() .AddInMemoryApiResources(Config.GetApiResources()) .AddInMemoryClients(Config.GetClients()) .AddTestUsers(Config.GetUsers());&#125; 使用UserMVC扩展方法，在Configure的管道中添加MVC作为最后一个中间件(middleware):12345678910111213public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseIdentityServer(); app.UseStaticFiles(); //添加MVC中间件 app.UseMvcWithDefaultRoute();&#125; 创建MVC客户端下一步，你将添加一个MVC应用程序到你的解决方案，可以使用’ASP.NET Core Web 应用程序’模板。在向导程序中，不要配置‘身份认证’设置，你将在这个项目中手动处理身份认证。项目创建完成后，参考（3）安装和概述配置，配置项目使用5002端口。 要向MVC应用程序添加OpenID Connect身份认证支持，添加以下代码到Startup的ConfigureServices方法中：12345678910111213141516171819202122public void ConfigureServices(IServiceCollection services)&#123; services.AddMvc(); JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear(); services.AddAuthentication(options =&gt; &#123; &#123; options.DefaultScheme = "Cookies"; options.DefaultChallengeScheme = "oidc"; &#125; &#125;) .AddCookie("Cookies") .AddOpenIdConnect("oidc", options =&gt; &#123; options.SignInScheme = "Cookies"; options.Authority = "http://localhost:5000"; options.RequireHttpsMetadata = false; options.ClientId = "mvc"; options.SaveTokens = true; &#125;);&#125; AddAuthentication添加身份认证服务到DI。我们使用cookies作为认证用户的主要方式(使用Cookies作为默认方案)。我们设置DefaultChallengeScheme的值为oidc，因为当需要用户登录时，我们将使用OpenID Connect 方案。 然后，我们使用AddCookie添加可以处理cookie的处理程序(handler)。 最后，使用AddOpenIdConnect配置执行OpenID Connect协议的处理程序 Authority：指示我们信任的IdentityServer地址 ClientId：识别客户端 SignInScheme： 一旦OpenID Connect协议完成，使用cookie处理程发出一个cookie SaveTokens：在cookie中持久化来自IdentityServer的令牌 此外，我们还关闭了JWT Claim类型映射，以允许众所周知的Claim(如’sub’和’idp’)在不受干扰的情况下通过: 1JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear(); 为确保身份认证服务在每个请求执行，在Startup.cs的Configure方法中添加UseAuthentication：12345678910111213141516public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; else &#123; app.UseExceptionHandler("/Error"); &#125; app.UseAuthentication(); app.UseStaticFiles(); app.UseMvcWithDefaultRoute();&#125; 身份认证中间件应该在MVC中间件之前添加到管道中。 最后一步是触发身份认证。转到home控制器，为一个Action添加[Authorize]特性。同时修改该Action的视图(View)，来展示Claims的信息：1234567&lt;dl&gt; @foreach (var claim in User.Claims) &#123; &lt;dt&gt;@claim.Type&lt;/dt&gt; &lt;dd&gt;@claim.Value&lt;/dd&gt; &#125;&lt;/dl&gt; 现在，如果你使用浏览器导航到这个路由，将尝试重定向到IdentyServer-这会返回一个错误结果，因为客户端还未注册。 为OpenID Connect身份作用域(Identity Scopes)添加支持与OAuth 2.0类似，OpenID Connect同样使用作用域概念。作用域代表你想保护以及客户端想访问的内容。对比OAuth，OIDC(OpenID Connenct)作用域并不是表示API，而是类似于用户id，姓名或者邮箱地址的用户身份数据。 通过添加一个新的帮助方法（在Config.cs）来创建IdentityResource对象集合，添加标准的openid(subject id)和profie(first name,last name等)的支持：123456789101112/// &lt;summary&gt;/// 添加身份资源(OpenId Connect)/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IEnumerable&lt;IdentityResource&gt; GetIdentityResources()&#123; return new List&lt;IdentityResource&gt; &#123; new IdentityResources.OpenId(), new IdentityResources.Profile(), &#125;;&#125; 注: 所有标准的作用域和它们对应的claims可以在OpenId Connect说明书里找到。 然后，你需要在StartUp.cs中添加这些身份资源到你的IdentityServer配置。在调用AddIdentityServer()的地方使用AddInMemoryIdentityResources扩展方法：123456789101112public void ConfigureServices(IServiceCollection services)&#123; services.AddMvc(); //IdentityServer配置in-memory存储,键(Keys),客户端和资源，测试用户 services.AddIdentityServer() .AddDeveloperSigningCredential() .AddInMemoryApiResources(Config.GetApiResources()) .AddInMemoryClients(Config.GetClients()) .AddTestUsers(Config.GetUsers()) .AddInMemoryIdentityResources(Config.GetIdentityResources());&#125; 为OpenID Connect隐式流添加客户端最后一步是向IdentityServer添加MVC客户端的新配置条目。 基于OpenID Connect的客户端与我们目前添加的OAuth 2.0客户端非常相似。但是，因为在OIDC的流是经常交互的，我们需要为配置添加一些重定向Urls。 将以下代码添加到你的客户端配置中：123456789101112131415161718192021222324252627282930/// &lt;summary&gt;/// 添加OpenID Connect客户端/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private static IEnumerable&lt;Client&gt; GetClients()&#123; var list = new List&lt;Client&gt;(); //使用用户凭据认证 var client = new Client &#123; ClientId = "mvc", ClientName = "MVC Client", //交互用户，使用OpenID Connect认证 AllowedGrantTypes = GrantTypes.Implicit, //登录后重定向地址 RedirectUris = &#123; "http://localhost:5002/signin-oidc" &#125;, //注销后重定向地址 PostLogoutRedirectUris = &#123; "http://localhost:5002/signout-callback-oidc" &#125;, //客户端要访问的作用域(Identity) AllowedScopes = &#123; IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile &#125; &#125;; list.Add(client); return list;&#125; 测试客户端现在，对新的MVC客户端，一切都已准备就绪。 导航到受保护的控制器Action来触发身份认证。你应该会看到一个重定向到IdentityServer的登录页。 使用IdentityServer中配置的用户名和密码登录成功后，屏幕上会显示同意页。在这里，用户可以决定是否要将身份信息发布到客户端应用程序。 最后，浏览器重定向返回到客户端应用程序，显示用户claims。 添加注销最后，是为MVC客户端添加注销功能。 像IdentityServer这样的身份认证权限服务，仅仅清除本地应用的cookies是不够的。此外，你还需要往返IdentityServer以清除中心单点登录(SSO)会话。 OpenID Connect中间件已经实现了准确的协议步骤，简单的在控制器填写以下代码来触发注销：12345public async Task LogOut()&#123; await HttpContext.SignOutAsync("Cookies"); await HttpContext.SignOutAsync("oidc");&#125; 这将清理本地的Cookie，然后重定向到IdentityServer。IdentityServer会清理掉它的Cookie并且为用户提供一个返回到MVC应用的链接。 进一步实验如上所诉，OpenID Connect中间件默认要求profile作用域。这个作用域同样可以包括像‘name’、‘website’等claims。 让我们为用户添加这些claims，因此IdentityServer可以把这些信息放到身份令牌(identity token)中：1234567891011121314151617181920212223242526272829303132public static List&lt;TestUser&gt; GetUsers()&#123; var users = new List&lt;TestUser&gt;(); var user = new TestUser() &#123; SubjectId = "1", Username = "ainslee", Password = "password", Claims = new[] &#123; new Claim("name","Ainslee"), new Claim("website","http://ainslee.io") &#125; &#125;; users.Add(user); user = new TestUser() &#123; SubjectId = "2", Username = "joyjoy", Password = "password", Claims = new[] &#123; new Claim("name","joyjoy"), new Claim("website","http://joyjoy.io") &#125; &#125;; users.Add(user); return users;&#125; 下次登录认证后，你的Claims页面会显示额外的claims信息。 请随意添加更多的claims和作用域。在OpenID Connect中间件上，Scope属性是您配置在身份验证期间将哪些作用域发送到IdentityServer的地方。 同样值得注意的是，检索令牌Claims是一个可扩展性点——IProfileService。由于我们使用的是AddTestUsers，所以TestUserProfileService默认使用。你可以参考源码，自定义自己的User用户。]]></content>
      <categories>
        <category>Identity Server 4</category>
      </categories>
      <tags>
        <tag>Identity Server 4</tag>
        <tag>Asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net Core身份认证框架IdentityServer4（5）使用密码保护API]]></title>
    <url>%2F2018%2F08%2F24%2Fids4_5_%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81%E4%BF%9D%E6%8A%A4API%2F</url>
    <content type="text"><![CDATA[OAuth 2.0 资源所有者密码授权(resource owner password grant)允许一个客户端发送用户名和密码到令牌服务器，然后返回一个访问令牌(access token)表示用户身份。 规范推荐你只有在可信任的应用才使用资源所有者密码授权。一般来说，当你想要对用户进行身份认证并请求访问令牌时，使用交互式的OpenId Connectiont授权通常会更加好。 然而，这种授权类型为我们介绍了用户(users)概念，因此我们在该例中使用它。 添加用户就像前篇为资源和客户端的在内存中存储，也有用于用户的存储。 TestUser类表示一个测试用户以及它的身份信息。我们通过添加以下代码到我们的Config类创建两个用户：12345678910111213141516171819202122public static List&lt;TestUser&gt; GetUsers()&#123; var users = new List&lt;TestUser&gt;(); var user = new TestUser() &#123; SubjectId = "1", Username = "ainslee", Password = "password" &#125;; users.Add(user); user = new TestUser() &#123; SubjectId = "2", Username = "joyjoy", Password = "password" &#125;; users.Add(user); return users;&#125; 然后用IdentityServer注册这些测试用户：123456789public void ConfigureServices(IServiceCollection services)&#123; //IdentityServer配置in-memory存储,键(Keys),客户端和资源，测试用户 services.AddIdentityServer() .AddDeveloperSigningCredential() .AddInMemoryApiResources(Config.GetApiResources()) .AddInMemoryClients(Config.GetClients()) .AddTestUsers(Config.GetUsers());&#125; AddTestUsers扩展方法在幕后做了一些事情 为资源所有者密码授权添加支持 为登录UI通常使用的用户关联服务添加支持（我们将会在下一章用到） 为基于测试用户的概要服务添加支持（我们将会在下一章中学到更多） 为资源所有者密码授权添加客户端你可以简单地通过改变AllowedGrantTypes属性，向现有的客户端添加该授权类型的支持。如果你希望你的客户端可以使用这两种授权类型，这也是完全支持的。 通常，您希望为资源所有者用例创建一个单独的客户端，添加以下代码到你的客户端配置：123456789101112131415161718public static IEnumerable&lt;Client&gt; GetClients()&#123; var list = new List&lt;Client&gt;(); var client = new Client() &#123; ClientId = "ro.client", AllowedGrantTypes = GrantTypes.ResourceOwnerPassword, ClientSecrets =&#123; new Secret("secret".Sha256()) &#125;, //客户端要访问的作用域(Api) AllowedScopes = &#123; "api1" &#125; &#125;; list.Add(client); return list;&#125; 使用密码授权方式请求令牌该客户端与我们之前的凭据授权客户端非常相似。主要的差异是当前客户端将会以某种方式收集用户的密码，然后在令牌请求时将它发送到令牌服务器。 同样的IdentityModel的TokenClient在这里可以为你提供帮助：12var tokenClient = new TokenClient(discovery.TokenEndpoint, "ro.client", "secret");var tokenResponse = await tokenClient.RequestResourceOwnerPasswordAsync("ainslee", "password", "api1"); 当你发送令牌到Identity API终结点，你注意到与凭据授权对比，有一个很小但是非常重要的不同。通过密码授权获取的访问令牌包含一个唯一标识用户身份的subclaim。通过在调用API之后检查内容变量，可以看到这个“sub”claim，控制台应用程序也将在屏幕上显示它。 子声明的存在(或不存在)使API能够区分代表客户机的调用和代表用户的调用。]]></content>
      <categories>
        <category>Identity Server 4</category>
      </categories>
      <tags>
        <tag>Identity Server 4</tag>
        <tag>Asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net Core身份认证框架IdentityServer4（4）使用客户端凭证保护API]]></title>
    <url>%2F2018%2F08%2F21%2Fids4_4_%E4%BD%BF%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%AD%E8%AF%81%E4%BF%9D%E6%8A%A4API%2F</url>
    <content type="text"><![CDATA[快速入门项目展示了使用IdentityServer保护API最基本的场景。在这个场景中，你将定义一个API和一个想访问它的客户端。客户端在IdentityServer请求一个访问令牌(access token)，然后使用令牌访问API。 定义API作用域定义了在系统中你想保护的资源：例如API。 因为我们使用内存中(in-memory)的配置来进行这个演练，所以添加API资源所需要做的就是，创建一个类型是ApiResource的对象并设置适当的属性。 添加文件(例如Config.cs)到你的项目中并添加以下代码：1234567public static IEnumerable&lt;ApiResource&gt; GetApiResources()&#123; return new List&lt;ApiResource&gt; &#123; new ApiResource("api1", "My API") &#125;;&#125; 注：需要添加引用 using IdentityServer4.Models; 定义客户端下一步就是定义一个访问API的客户端。 在这个场景中，客户端并没有一个交互的用户。我们将用一个所谓的机密(secret)客户端来使用IdentityServer进行身份认证。添加以下代码到你的Config.cs文件：123456789101112131415161718192021public static IEnumerable&lt;Client&gt; GetClients()&#123; var list = new List&lt;Client&gt;(); var client = new Client &#123; ClientId = "client", //非交互用户，使用Clientid/Secret认证 AllowedGrantTypes = GrantTypes.ClientCredentials, //认证的Secret ClientSecrets =&#123; new Secret("secret".Sha256()) &#125;, //客户端要访问的作用域(Api) AllowedScopes = &#123; "api1" &#125; &#125;; list.Add(client); return list;&#125; 配置IdentityServer配置IdentityServer使用你定义的作用域和客户端，你需要在ConfigureServices方法中添加代码。你可以用如下代码，使用约定的扩展方法添加相关存储和数据到依赖注入(DI)系统：12345678public void ConfigureServices(IServiceCollection services)&#123; //IdentityServer配置in-memory存储,键(Keys),客户端和资源 services.AddIdentityServer() .AddDeveloperSigningCredential() .AddInMemoryApiResources(Config.GetApiResources()) .AddInMemoryClients(Config.GetClients());&#125; 如果你运行服务，然后再浏览器中导航到http://localhost:5000/.well-known/openid-configuration链接，你会看到所谓的发现文档(discovery document)。这将被你的客户端和API用来下载必要的配置数据。 添加API下一步，添加一个API到你的解决方案。 你可以使用ASP.NET Core Web Api模板。参考（3）安装和概述，配置端口到5001。本次演练假设你已经配置你API运行在http://localhost:5001主机上。 控制器添加一个新的控制器文件到你的API项目：1234567891011121314151617[Route("identity")][Authorize]public class IdentityController : ControllerBase&#123; [HttpGet] public IActionResult Index() &#123; var users = from claim in User.Claims select new &#123; claim.Type, claim.Value &#125;; return new JsonResult(users); &#125;&#125; 这个控制器稍后会被用来测试用户认证，同样为API的身份信息提供可视化。 配置最后一步是添加身份认证服务到依赖注入(DI)以及添加身份认证中间件(authentication middleware)到管道。这会： 验证进入的令牌，确定它来自可信任的发行机构 验证令牌对API(作用域)是有效的 在项目中添加IdentityServer4.AccessTokenValidationNuGet包。1PM&gt; Install-Package IdentityServer4.AccessTokenValidation 然后更新Startup.cs文件：123456789101112131415161718192021222324252627public void ConfigureServices(IServiceCollection services)&#123; services.AddMvcCore() .AddAuthorization() .AddJsonFormatters(); services.AddAuthentication("Bearer") .AddIdentityServerAuthentication( options =&gt; &#123; options.Authority = "http://localhost:5000"; options.RequireHttpsMetadata = false; options.ApiName = "api1"; &#125;);&#125;public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseAuthentication(); app.UseMvc();&#125; AddAuthentication扩展方法添加身份认证服务到依赖注入(DI)并且配置Bearer作为默认的方案。AddIdentityServerAuthentication扩展方法为身份认证服务的使用添加IdentityServer访问令牌认证Handler到依赖注入(DI)。UseAuthentication添加身份认证中间件到管道，这样每次请求主机，身份认证将会自动执行。 如果你在浏览器导航到控制器http://localhost:5001/identity，你会得到一个401状态码的返回结果。这表示你的API需要一个凭据。 创建客户端最后一步是创建一个请求访问令牌的客户端，然后使用这个令牌访问API。本例我们添加一个控制台(Console)项目到解决方案。 这个令牌终结点在IdentityServer中实现了OAuth2.0协议，你可以使用原始的HTTP请求访问它。然而，我们有一个叫做IdentityModel的客户端库，它将协议交互封装在一个易于使用的API中。 在项目中添加IdentityModelNuGet包。1PM&gt; Install-Package IdentityModel IdentityModel包含一个客户端库，可以与discovery endpoint一起使用。这样，您只需要知道IdentityServer的基本地址——实际的端点地址可以从元数据中读取:123456var discovery = await DiscoveryClient.GetAsync("http://localhost:5000");if (discovery.IsError)&#123; Console.WriteLine(discovery.Error); return;&#125; 注：需要添加应用using IdentityModel.Client; 然后，你可以使用RequestClientCredentialsAsync方法为你的API请求一个令牌：12345678910var tokenClient = new TokenClient(discovery.TokenEndpoint, "client", "secret");var tokenResponse = await tokenClient.RequestClientCredentialsAsync("api1");if (tokenResponse.IsError)&#123; Console.WriteLine(tokenResponse.Error); return;&#125;Console.WriteLine(tokenResponse.Json); 注：从控制台复制和粘贴访问令牌到jwt.io验证原始的token 最后一步是访问调用API。 我们普遍的使用HTTP Authorization header发送访问令牌到API。可以使用SetBearerToken扩展方法完成：123456789101112131415var client = new HttpClient();client.SetBearerToken(tokenResponse.AccessToken);var response = await client.GetAsync("http://localhost:5001/identity");if (!response.IsSuccessStatusCode)&#123; Console.WriteLine(response.StatusCode);&#125;else&#123; var content = await response.Content.ReadAsStringAsync(); Console.WriteLine(JArray.Parse(content));&#125; 输出结果如下： 注：默认情况下，一个访问令牌会包括作用域的信息，生命周期，客户端ID以及令牌发行人名称。 完整的客户端代码如下：客户端代码]]></content>
      <categories>
        <category>Identity Server 4</category>
      </categories>
      <tags>
        <tag>Identity Server 4</tag>
        <tag>Asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net Core身份认证框架IdentityServer4（3）安装和概述]]></title>
    <url>%2F2018%2F08%2F16%2Fids4_3_%E5%AE%89%E8%A3%85%E5%92%8C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[开始一个新的IdentityServer项目有两种基本的方式： 从头开始 在Visual Studio中使用ASP.NET Identity模板开始 如果你从头开始，我们提供了一些帮助和in-memory的存储。因此，你不必一开始就担心持久(persistence)性。 如果你从ASP.NET Identity模板开始，我们同样提供了一种简单的方法来集成。 快速入门教程为多种常见的IdentityServer场景提供了逐步地指导。它们从绝对的基础知识开始，然后变的更加复杂–建议你按序操作。 每个快速入门项目有一个相关的解决方案，你可以在Quickstarts文件夹中的IdentityServer4.Samples找到源码。 基本安装屏幕中的截图显示的是Visual Studio-但这不是必须的。 创建 QuickStart IdentityServer 通过创建Asp.NET Core Web 应用程序开始。 选择空项目模板。 然后添加 IdentityServer4 nuget 包。可在 菜单栏-工具-Nuget包管理器-程序包管理器控制台打开控制台，然后运行以下命令添加包依赖1PM&gt; Install-Package IdentityServer4 注意：IdentityServer 1.x 版本使用ASP.NET Core 1.1,IdentityServer 2.x 版本使用ASP.NET Core 2.0。 IdentityServer使用常规模式来配置和添加服务到ASP.NET Core宿主。在ConfigureServices中，必要的服务被配置并且添加到依赖注入(DI)系统。在Configure中，中间件(middleware)被添加到HTTP管道中。 如下修改你的Startup.cs文件：123456789101112131415public void ConfigureServices(IServiceCollection services)&#123; services.AddIdentityServer() .AddDeveloperSigningCredential();&#125;public void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseIdentityServer();&#125; AddIdentityServer在依赖注入(DI)中注册IdentityServer服务。它还为运行时状态注册一个In-Memory的存储，这对开发场景非常有用。在生产场景中，你需要一个像数据库或缓存一样的持久化或共享存储。 AddDeveloperSigningCredential扩展为登录token创建了一个临时的key。这可能对开始学习很有用，但是在生产场景中，你应该使用持久化Key替换掉它。 注：IdentityServer未为启动做好准备，我们将会在接下来的示例中添加必须的服务。 修改主机Visual Studio默认使用IIS Express来寄宿你的Web项目。这是很好的方式，除了你不能从控制台看到时时输出的日志。 IdentityServer 广泛的使用日志记录，然而在UI或者返回到客户端可见的错误信息是故意模糊的。 我们推荐在控制台宿主(console host)中运行IdentityServer。可以通过项目(鼠标右键)-属性-调试-启动中选择下拉项[项目]，如下图： 为了方便后续示例，我们统一将项目端口设置为5000，见上图 Web服务器设置-应用Url:http:localhost:5000。]]></content>
      <categories>
        <category>Identity Server 4</category>
      </categories>
      <tags>
        <tag>Identity Server 4</tag>
        <tag>Asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置ssh将本地仓库提交到github仓库]]></title>
    <url>%2F2018%2F08%2F13%2F%E9%85%8D%E7%BD%AEssh%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%8F%90%E4%BA%A4%E5%88%B0github%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[配置ssh配置账号和密码12$ git config --global user.name "myUsername" //配置你的账户名字$ git config --global user.email "myEmail" //配置你的创建github账户的邮箱 配置完成后，可通过以下命令查看配置的结果12$ git config user.name$ git config user.email 显示结果 myUserNamemyEmail 生成ssh文件使用git bash控制台，输入以下指令：1$ ssh-keygen -t rsa -C "myEmail" 注：myEmail输入你实例的github邮箱！！！创建完成之后，显示以下信息。提示你输入文件名，如果你在本机有多个ssh，则输入你指定的名称，若为空，则使用默认名称id_rsa Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/wa02827/.ssh/id_rsa): 创建完成后，我们在个人用户目录c/Users/wa02827(当前登录名，不同用户会有不同的文件夹)/.ssh下看到id_rsa(私钥)和id_rsa.pub(公钥)两个文件。 在github上配置公钥使用记事本打开你要上传的公钥（本例：id_rsa.pub)，内容如下： ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC5Ez0jbSECncu+SzUDjc/JIzwco9hVg62kYcCIocpYnazn98pK5/fI1wJ/M8nogDwIjX9/u74qSLLojGNhAwuwuEEDjGUS8R6kR+Hn9tlUsLoARyJIfSiy9PUSqQX5RwowN9q0QAuDipGVZVnOzHLIdNccaJ06zTgWPxv+JyrB+Bu6GuXujlDvKWGE6gUpTE4fFA6rQp+KCRAdE1cboxiGSLo2xZ5xSiATK6gw61N1J2LeFAsecH8CSYKltPTYwIPfA2e7a/+U916ZRlQXKiKLCDmfdHCzL4h0g6BAMK304/k81k7DAVNCRLcIiNyP7KAvNJFXlq08e+984DkiwrMt 在github上，Settings-&gt;SSH and GPG keys点击New SSH Key按钮，将id_rsa.pub公钥数据复制到Key文本框，保存完成。 修改配置文件（单机器多个ssh重点）检查用户/.ssh目录下，是否有config文件，若是没有，新建名称为config的文件(注：该文件没有文件类型后缀)。 编辑文件，添加以下内容： ##别名，github默认为：github.comHost github_wu.com ##数组名称HostName github.com ##账号User gitPreferredAuthentications publickey ##指定私钥文件，默认为~/.ssh/id_rsaIdentityFile ~/.ssh/id_rsa.wu ~/.ssh/id_rsa.wu为生成ssh时，个人指定的文件路径，默认名称为~/.ssh/id_rsa。 测试ssh使用一下命名，测试ssh是否可用1$ ssh -T -V git@github_wu.com 成功显示如下： Hi tangname! You’ve successfully authenticated, but GitHub does not provide shell access. 实际使用的时候，例如Clone仓库，这可以使用以下命令1$ git clone git@github_wu.com:tangname/myblog.git 默认为 git@github.com:tangname/myblog.git 以上信息中，tangname为个人的github用户名，myblog.git为仓库名称。 配置本地仓库和远程仓库关联若是直接通过git clone命令获取远程仓库，默认会添加关联。这里给出本地仓库先创建，而远程仓库还是空的时候，如何将本地仓库关联到远程仓库。 此处省略在github创建仓库步骤。 若远程仓库有文件(readme.md等)，首选获取远程仓库，命令如下：注：若是远程仓库为空，该步可以省略1$ git pull 然后将获取的文件提交到本地仓库12$ git add *$ git commit -m '提示消息' 添加关联1$ git remote add origin git@github.com:tangname/myblog.git 注：若是ssh配置了别名，则按配置的别名使用，例如使用 一、4、修改配置文件的配置，则命令如下：1$ git remote add origin git@github_wu.com:tangname/myblog.git 查看已配置的远程仓库1$ git remote 列表显示origin，表明该远程仓库已经关联成功。 然后执行命令，将本地仓库推送到远程仓库:1$ git push origin master 其中，origin为远程仓库别名，master为远程仓库中的分支名称。 至此，所有步骤完成。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net Core身份认证框架IdentityServer4（2）术语]]></title>
    <url>%2F2018%2F08%2F11%2Fids4_2_%E6%9C%AF%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[规范、文档和模型对象使用一些你应该知道的术语。 IdentityServerIdentityServer是一个OpenID Connect的提供程序。它实现了OpenID Connect和OAuth 2.0协议。 不同的文献对相同的角色使用不同的术语——您可能还会找到安全令牌服务(security token service)、身份提供者(identity provider)、授权服务器(authorization server)、IP-STS等等。 总而言之它们都是一样的：向客户端颁发安全令牌(security tokens) IdentityServer 有许多功能： 保护你的资源 使用本地存储账号或者外部身份提供程序对用户进行身份认证 提供会话(Session)管理和单点登陆(SSO) 管理和认证客户端 向客户端发出标识(Identity tokens)和访问令牌(access tokens) 验证令牌(validate tokens) User用户(User)是使用已注册的客户端(registered client)去访问资源(resources)的人。 Client客户端(Client)是从IdentityServer请求令牌(token)的软件，用于认证用户(请求identity token)或者访问资源(请求access token)。客户端在请求令牌前，必须先向IdentityServer注册。 客户端可以是Web应用，本地移动或桌面应用，单页应用(SPA)，服务进程(server process)等。 Resources资源(Resource)是你希望IdentityServer要保护的内容-你的用户身份数据(identity data)或APIs。 每个资源有唯一的名称-Client通过这个名称来指定它们想要访问的资源。 身份数据(identity data)资源：关于用户的身份西信息，例如用户名、邮箱地址等。 API资源: Api资源表示客户端想要调用的功能-通常建模为 Web Api，但不是必须的。 Identity Token身份令牌(Identity Token)表示身份认证(authentication)的结果。它至少包含用户的标识符，还包含用户的认证时间和认证方式。它还可以包含一些额外的身份数据。 Access Token访问令牌(access token)允许访问API资源。客户端请求访问令牌并将它们转发到API。访问令牌包含客户端信息和用户信息(如果存在)，API使用这些信息去授权(Autorize)访问其数据。]]></content>
      <categories>
        <category>Identity Server 4</category>
      </categories>
      <tags>
        <tag>Identity Server 4</tag>
        <tag>Asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net Core身份认证框架IdentityServer4（1）目录]]></title>
    <url>%2F2018%2F08%2F11%2FIds4_1_%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[术语 安装和概述 使用客户端凭证保护API 使用密码保护API 使用OpenID Connect添加用户认证 切换到混合流并添加API访问 注：本系列翻译仅用于个人学习记录以及英语练习英语，他人看到请尽量看原文或其他翻译比较好的文章。]]></content>
      <categories>
        <category>Identity Server 4</category>
      </categories>
      <tags>
        <tag>Identity Server 4</tag>
        <tag>Asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next常见问题处理]]></title>
    <url>%2F2018%2F07%2F28%2Fnext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[如何为next添加背景图1.下载图片，放到主题的images目录下 2.修改主题的/source/css/_custom/_custom.styl文件，添加123body &#123; background:url(/images/background.jpg) &#125; next引用标签(blockquote)中的内容不超出屏幕不自动换行修改主题的/source/css/_custom/_custom.styl文件，添加123blockquote &#123; word-break: break-all;&#125; 如何为文章添加图片首先修改配置文件_config.ymlf的post_asset_folder项值为true 使用命令创建新的博客：1$ hexo new "blogname" 创建后，source/_post 目录下会出现一个blogname.md的博客文件和一个标题同名的关联文件夹。 将图片放到关联文件后，通过以下代码显示图片1&#123;% asset_img test_image01.png %&#125; hexo推荐使用该方式显示图片，而不是Markdown的![alet](url)语法。这样可以避免在首页图片无法显示的问题。 注:该方法显示图片，需要hexo版本在3.0以及以上。 如何为站点添加相册功能如何为站点添加相册功能 当前使用的改进方法]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用hexo搭建博客]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提在安装 hexo 前，您必须检查电脑中是否已安装下列应用程序： nodejs git 项目安装本教程环境为win10，程序安装完成后，使用管理员权限打开控制台，使用npm完成对hexo的安装1$ npm install -g hexo-cli 安装完成后，新建空的项目文件夹，cd到该目录下后，对hexo初始化项目1$ hexo init 安装完成后，使用以下命令生成新的博客，生成的博客在\source\_posts目录下。1$ hexo new "mysirtblog" 然后清空缓，然后存生成静态文件123$ hexo clean$ hexo generate 启动服务，预览效果1$ hexo server 运行后如下图所示 注：hexo默认使用4000端口，如果该端口已被其他程序占用（例如福昕pdf），会运行失败。可以指定端口运行:1$ hexo server -p 5000 至此 hexo 全部安装完成。 Next 博客模板接下来我们安装 Next 模板，该模板是一套非常简洁的博客模板，你也可以选择其他喜欢的模板安装。 安装Next模板通过git下载模板，你也可以直接在git上下载该模板的zip包，然后解压到站点的themes目录下。 1$ git clone https://github.com/theme-next/hexo-theme-next.git themes/next 下载完成后，cd到themes/next目录，初始化next的依赖包1$ npm install 启用主题打开站点配置文件（根目录的_config.yml)，找到 theme 字段，并将其值更改为 next。 theme: next 关于next更多的操作，可见官网。 Hexo 常用命令123456789$ hexo new "mysirtblog" *//新建博客*$ hexo clean //清空缓存数据$ hexo generate //生成博客静态文件$ hexo server -p 5000 //运行博客站点，若不制定端口 -p 5000 ，则默认使用http://localhost:4000端口$ hexo deploy //发布站点]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
